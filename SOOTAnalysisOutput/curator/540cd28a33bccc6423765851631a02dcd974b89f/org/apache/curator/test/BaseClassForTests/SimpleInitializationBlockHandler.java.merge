package org.apache.curator.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.IInvokedMethod;
import org.testng.IInvokedMethodListener2;
import org.testng.IRetryAnalyzer;
import org.testng.ITestContext;
import org.testng.ITestNGMethod;
import org.testng.ITestResult;
import org.testng.TestListenerAdapter;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;
import java.io.IOException;
import java.net.BindException;
<<<<<<< MINE
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
=======
>>>>>>> YOURS

public class BaseClassForTests {

    protected TestingServer server;

<<<<<<< MINE
    private final Logger log = LoggerFactory.getLogger(getClass());

    private static final int RETRY_WAIT_MS = 5000;

=======
>>>>>>> YOURS
    private static final String INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES;

<<<<<<< MINE
    private static final String INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND;

    private static final String INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY;

=======
>>>>>>> YOURS
    static {
        String logConnectionIssues = null;
        try {
            Class<?> debugUtilsClazz = Class.forName("org.apache.curator.utils.DebugUtils");
            logConnectionIssues = (String) debugUtilsClazz.getField("PROPERTY_DONT_LOG_CONNECTION_ISSUES").get(null);
        } catch (Exception e) {
            e.printStackTrace();
        }
        INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES = logConnectionIssues;
<<<<<<< MINE
        String s = null;
        try {
            s = (String) Class.forName("org.apache.curator.utils.DebugUtils").getField("PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND").get(null);
        } catch (Exception e) {
            e.printStackTrace();
        }
        INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND = s;
        s = null;
        try {
            s = (String) Class.forName("org.apache.curator.utils.DebugUtils").getField("PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY").get(null);
        } catch (Exception e) {
            e.printStackTrace();
        }
        INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY = s;
=======
>>>>>>> YOURS
    }

    @BeforeSuite(alwaysRun = true)
    public void beforeSuite(ITestContext context) {
        context.getSuite().addListener(new MethodListener(log, enabledSessionExpiredStateAware()));
    }

    @BeforeMethod
    public void setup() throws Exception {
        if (INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES != null) {
            System.setProperty(INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES, "true");
        }
        System.setProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND, "true");
        System.setProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY, "true");
        while (server == null) {
            try {
                server = new TestingServer();
            } catch (BindException e) {
                System.err.println("Getting bind exception - retrying to allocate server");
                server = null;
            }
        }
    }

    @AfterMethod
    public void teardown() throws Exception {
        System.clearProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY);
        System.clearProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND);
        if (server != null) {
            try {
                server.close();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                server = null;
            }
        }
    }

    protected boolean enabledSessionExpiredStateAware() {
        return false;
    }

<<<<<<< MINE
    private static class RetryContext {

        final AtomicBoolean isRetrying = new AtomicBoolean(false);

        final AtomicInteger runVersion = new AtomicInteger(0);
    }

    private static class RetryAnalyzer implements IRetryAnalyzer {

        private final Logger log;

        private final RetryContext retryContext;

        RetryAnalyzer(Logger log, RetryContext retryContext) {
            this.log = log;
            this.retryContext = retryContext;
        }
=======
        private boolean wasRetried = false;
>>>>>>> YOURS

        @Override
        public boolean retry(ITestResult result) {
<<<<<<< MINE
            if (result.isSuccess() || retryContext.isRetrying.get()) {
                retryContext.isRetrying.set(false);
                return false;
            }
            log.error("Retrying 1 time");
            retryContext.isRetrying.set(true);
            return true;
        }
    }

    private static class MethodListener implements IInvokedMethodListener2 {

        private final Logger log;

        private final boolean sessionExpiredStateAware;

        private static final String ATTRIBUTE_NAME = "__curator";

        MethodListener(Logger log, boolean sessionExpiredStateAware) {
            this.log = log;
            this.sessionExpiredStateAware = sessionExpiredStateAware;
        }

        @Override
        public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {
        }

        @Override
        public void afterInvocation(IInvokedMethod method, ITestResult testResult) {
        }

        @Override
        public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {
            if (method.getTestMethod().isBeforeMethodConfiguration()) {
                RetryContext retryContext = (RetryContext) context.getAttribute(ATTRIBUTE_NAME);
                if (retryContext == null) {
                    retryContext = new RetryContext();
                    context.setAttribute(ATTRIBUTE_NAME, retryContext);
                }
                if (!sessionExpiredStateAware) {
                    System.setProperty("curator-use-classic-connection-handling", Boolean.toString(retryContext.runVersion.get() > 0));
                    log.info("curator-use-classic-connection-handling: " + Boolean.toString(retryContext.runVersion.get() > 0));
                }
            } else if (method.isTestMethod()) {
                method.getTestMethod().setRetryAnalyzer(new RetryAnalyzer(log, (RetryContext) context.getAttribute(ATTRIBUTE_NAME)));
            }
        }

        @Override
        public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {
            if (method.getTestMethod().isBeforeSuiteConfiguration() && !sessionExpiredStateAware) {
                for (ITestNGMethod testMethod : context.getAllTestMethods()) {
                    testMethod.setInvocationCount(2);
                }
=======
            if (result.isSuccess() || wasRetried) {
                wasRetried = false;
                return false;
>>>>>>> YOURS
            }
<<<<<<< MINE
            if (method.isTestMethod()) {
                RetryContext retryContext = (RetryContext) context.getAttribute(ATTRIBUTE_NAME);
                if (retryContext == null) {
                    log.error("No retryContext!");
                } else {
                    System.clearProperty("curator-use-classic-connection-handling");
                    if (testResult.isSuccess() || (testResult.getStatus() == ITestResult.FAILURE)) {
                        retryContext.isRetrying.set(false);
                        if (retryContext.runVersion.incrementAndGet() > 1) {
                            context.setAttribute(ATTRIBUTE_NAME, null);
                        }
                    }
                }
            }
=======
            wasRetried = true;
            System.err.println(String.format("Retry test 1 time. Name: %s - TestName: %s ", result.getName(), result.getTestName()));
            return true;
>>>>>>> YOURS
        }
    }
}